# 만들면서 배우는 클린아키텍처.md

## 4. 유스케이스 구현하기
일반적으로 유스케이스가 하는 일
1. 입력을 받는다.
2. 비즈니스 규칙을 검증한다.
3. 모델 상태를 조작한다.
4. 출력을 반환한다.

유스케이스는 비즈니스 규칙을 검증하는 책임이 있다. 도메인 엔티티와 이 책임을 공유한다.

### 유효성 검증
- 유스케이스 코드가 도메인 로직에만 신경 써야 하고 입력 유효성 검증으로 오염되면 안 된다고 생각한다.
- 유스케이스를 호출하는 쭉에서 검증을 한다면? 유스케이스는 하나 이상의 어댑터에서 호출될 텐데 그러면 유효성 검증을 각 어댑터에서 전부 구현해야 한다. 비효율.
- 유스케이스의 입력 모델이 스스로 검증을 하도록 하자
- 입력모델도 유스케이스 API의 일부이다. 인커밍 포트 패키지에 위치한다.

### 생성자

- 생성자가 너무 많으면 빌더 패턴을 사용하곤 한다.
- 빌더 패턴을 많이 사용하는데 단점은 빌더를 호출하는 코드에 새로운 필드를 추가하는 것을 잊을 수 있다. 즉, 필드 추가가 강제 되지 않는다.
- 요즘 IDE들은 매우 훌륭하다. 생성자도 이쁘게 잘 보여 준다.

### 유스케이스마다 다른 입력 모델

- 계좌 등록하기
- 계좌 정보 업데이트 하기

필드가 똑같은 계좌 상세 정보가 있는 입력 모델이 있다. 다른 유스케이스에 동일한 입력 모델을 사용하고 싶다. 

완벽하게 같지 않을 수 있다. 이런 경우 유스케이스에서 사용하지 않는 필드가 포함되어 있을 수 있다. 이런 필드를 검증하기 위해 검증 로직이 추가되어야 한다. 이는 관심사를 분산 시킨다.

- 각 유스케이스 전용 입력 모델은 유스케이스를 훨씬 명확하게 만든다.

### 비즈니스 규칙 검증

비즈니스 규칙 검증은 어떻게 규현할까? 가장 좋은 방법은 비즈니스 규칙을 도메인 엔티티 안에서 해결 하는것이다. 

### 풍부한 도메인 모델

- DDD 철학을 따르는 풍부한 도메인 모델
- 애플리케이션의 코어에 있는 엔티티에서 가능한 한 많은 도메인 로직이 구현된다.

### 빈약한 도메인 모델

엔티티는 상태를 표현하는 필드와 이 값을 읽고 바꾸기 위한 `getter`, `setter`메서드만 포함하고 도메인 로직이 없다. 

도메인 로직은 유스케이스에 구현되어 있다. 두꺼운 service

### 유스케이스 마다 다른 출력

- 유스케이스들 간에 같은 출력 모델을 공유하는 것은 유스케이스들도 강하게 결합하게 만들 수 있다. 모두 같이 변경되기 때문이다.

### 읽기 전용 유스케이스

- 읽기 전용 작업을 유스케이스라고 언급하기엔 조금 이상하다.
- CQRS

### 부수효과

입출력 모델을 독립적으로 모델링한다면 각 유스케이스마다 별도의 모델을 만들어야 하고 이 모델과 엔티티를 매핑해야 한다. 

그러나 유스케이스별 모델을 만들면 유스케이스를 명확하게 이해할 수 있고 장기적으로 유지보수하기 더 쉽다.