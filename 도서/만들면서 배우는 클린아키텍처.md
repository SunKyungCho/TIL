# 만들면서 배우는 클린아키텍처.md

## 4. 유스케이스 구현하기
일반적으로 유스케이스가 하는 일
1. 입력을 받는다.
2. 비즈니스 규칙을 검증한다.
3. 모델 상태를 조작한다.
4. 출력을 반환한다.

* 유스케이스는 비즈니스 규칙을 검증하는 책임이 있다. 도메인 엔티티와 이 책임을 공유한다.

**유효성 검증**
- 유스케이스 코드가 도메인 로직에만 신경 써야 하고 입력 유효성 검증으로 오염되면 안 된다고 생각한다.
- 유스케이스를 호출하는 쭉에서 검증을 한다면? 유스케이스는 하나 이상의 어댑터에서 호출될 텐데 그러면 유효성 검증을 각 어댑터에서 전부 구현해야 한다. 비효율.
- 유스케이스의 입력 모델이 스스로 검증을 하도록 하자
- 입력모델도 유스케이스 API의 일부이다. 인커밍 포트 패키지에 위치한다.

**생성자**

- 생성자가 너무 많으면 빌더 패턴을 사용하곤 한다.
- 빌더 패턴을 많이 사용하는데 단점은 빌더를 호출하는 코드에 새로운 필드를 추가하는 것을 잊을 수 있다. 즉, 필드 추가가 강제 되지 않는다.
- 요즘 IDE들은 매우 훌륭하다. 생성자도 이쁘게 잘 보여 준다.

**유스케이스마다 다른 입력 모델**

```
- 계좌 등록하기
- 계좌 정보 업데이트 하기
```
* 필드가 똑같은 계좌 상세 정보가 있는 입력 모델이 있다. 다른 유스케이스에 동일한 입력 모델을 사용하고 싶다. 

* 완벽하게 같지 않을 수 있다. 이런 경우 유스케이스에서 사용하지 않는 필드가 포함되어 있을 수 있다. 이런 필드를 검증하기 위해 검증 로직이 추가되어야 한다. 이는 관심사를 분산 시킨다.

- 각 유스케이스 전용 입력 모델은 유스케이스를 훨씬 명확하게 만든다.

**비즈니스 규칙 검증**

* 비즈니스 규칙 검증은 어떻게 규현할까? 가장 좋은 방법은 비즈니스 규칙을 도메인 엔티티 안에서 해결 하는것이다. 

**풍부한 도메인 모델**
- DDD 철학을 따르는 풍부한 도메인 모델
- 애플리케이션의 코어에 있는 엔티티에서 가능한 한 많은 도메인 로직이 구현된다.

**빈약한 도메인 모델**
* 엔티티는 상태를 표현하는 필드와 이 값을 읽고 바꾸기 위한 `getter`, `setter`메서드만 포함하고 도메인 로직이 없다. 
* 도메인 로직은 유스케이스에 구현되어 있다. 두꺼운 service

**유스케이스 마다 다른 출력**
- 유스케이스들 간에 같은 출력 모델을 공유하는 것은 유스케이스들도 강하게 결합하게 만들 수 있다. 모두 같이 변경되기 때문이다.

**읽기 전용 유스케이스**
- 읽기 전용 작업을 유스케이스라고 언급하기엔 조금 이상하다.
- CQRS

**부수효과**

* 입출력 모델을 독립적으로 모델링한다면 각 유스케이스마다 별도의 모델을 만들어야 하고 이 모델과 엔티티를 매핑해야 한다. 
* 그러나 유스케이스별 모델을 만들면 유스케이스를 명확하게 이해할 수 있고 장기적으로 유지보수하기 더 쉽다.\

## 5. 웹 어댑터 구현하기
![영속성 어댑터](../assert/images/controller.png)
- 애플리케이션 코어가 외부 세계와 통신하는 명세이다.
- 의존성 역전 원칙이 적용되어 있다.

## 웹어댑터의 책임

1. HTTP 요청을 자바 객체로 매핑
2. 권한 검사
3. 입력 유효성 검증
4. 입력을 유스케이스의 입력 모델로 매핑
5. 유스케이스 호출
6. 유스케이스 출력을 HTTP로 매핑
7. HTTP 응답을 반환

### Controller

- 컨트롤러 너무 적은 것보다는 너무 많은게 낫다.
    - 작은 클래스들은 더 파악하기 쉽다.
    - 테스트가 쉽다.
    - 조금 더 공수는 들지만 유지보수가 편해진다.
- 각 컨트롤러가 가능한 좁고 다른 컨트롤러와 가능한 한 적게 공유하는 웹 어댑터 조각을 구현해야 한다.
- 가급적 메서드와 클래스명은 유스케이스를 최대한 방영해서 지어야 한다.
- 대부분 request, response 객체들도 컨트롤러에 맞는 모델을 새로 만드는 것이 좋다. 그렇게 되더라
- 컨트롤러, 서비스명도 잘 생각해봐야 한다. (제일 어렵다....😥)
- HTTP요청 대해 유스케이스 메서드를 호출하고 반환한다. 어떤 도메인 로직도 수행하지 않는다.

## 6. 영속성 어댑터 구현하기

![영속성 어댑터](../assert/images/persistence.png)

* Application 서비스와 영속성 코드 사이의 간접적인 계층이다. 
* 영속성 문제에 신경쓰지 않고 도메인 코드를 개발할 수 있게 해준다. 

### 영속성 어탭터가 하는일
1. 입력을 받는다.
2. 입력을 데이터베이스 포맷으로 매핑한다.
3. 입력을 데이터베이스로 보낸다.
4. 데이터베이스 출력을 애플리케이션 포맷으로 매핑한다.
5. 출력을 반환한다. 


* 데이터베이스 응답을 포트에 정의된 출력 모델로 매핑해서 반환한다. 
* 출력 모델이 영속성 어댑터가 아니라 애플리케이션 코어에 위치 한다. 
* 하나의 `repository`에 모두 담기보다는 인터페이스를 분리하여 작성하는게 도움이 된다.

![인터페이스분리원칙을따른예시](../assert/images/split_interface_persistence.png)

* Aggregate 하나당 하나의 영속성 어댑터(repository)들을 나누면 좀 더 의도가 분명해 진다.
* DDD의 Bounded context의 영속성 요구사항은 분리하기 위한 좋은 토대가 돤다.
* 영속성 측면 `@Anotation` 등과 섞이지 않는 풍부한 도메인 모델을 생성하고 싶다면 모델과 영속성 모델을 매핑하는게 좋다. 
* 트랜잭션은 유스케이스에 대해서 일어나는 일에 걸쳐 있어야 한다. 그래서 실패할때 한번에 롤백될 수 있다. 
* `@Transactional` 어노테이션을 애플리케이션 서비스 클래스에 붙여준다. 
